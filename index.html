<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FrameCraft Pro - Professional Image Processing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        gray: {
                            750: '#2d3748',
                            850: '#1a202c',
                            950: '#0d1117',
                        },
                        accent: {
                            500: '#6366f1',
                            600: '#4f46e5',
                        }
                    },
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { font-family: 'Inter', sans-serif; }
        body { background-color: #0d1117; color: #f8fafc; margin: 0; padding: 0; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        .spinner {
            border: 3px solid #374151;
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .animate-fade-in {
            animation: fade-in 0.3s ease-out forwards;
        }
        
        .drop-zone {
            transition: all 0.3s ease;
        }
        
        .drop-zone.dragover {
            border-color: #6366f1;
            background-color: rgba(99, 102, 241, 0.1);
        }
        
        .toast {
            animation: slide-in 0.3s ease-out forwards;
        }
        
        @keyframes slide-in {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        .progress-bar {
            transition: width 0.3s ease;
        }

        .quality-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .quality-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="app" class="h-screen flex flex-col overflow-hidden">
        <!-- Header -->
        <header class="h-14 border-b border-gray-800 flex items-center justify-between px-4 bg-gray-900/90 backdrop-blur-md z-30 shrink-0">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center shadow-lg shadow-indigo-500/20">
                    <svg class="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                </div>
                <h1 class="font-bold text-lg tracking-tight hidden md:block">FrameCraft <span class="text-indigo-400 text-sm font-semibold">Pro</span></h1>
            </div>
            
            <div class="flex items-center gap-3">
                <div id="imageCount" class="text-xs mr-2 hidden sm:block text-gray-400">0 images loaded</div>
                
                <button id="addImagesBtn" class="text-sm font-medium text-white bg-gray-800 hover:bg-gray-700 transition-colors flex items-center gap-2 px-3 py-1.5 rounded-md border border-gray-700">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    Add Images
                </button>
                
                <button id="clearAllBtn" class="hidden text-sm font-medium text-gray-400 hover:text-white bg-gray-800 hover:bg-gray-700 transition-colors items-center gap-2 px-3 py-1.5 rounded-md border border-gray-700">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    Clear All
                </button>
                
                <button id="processAllBtn" class="hidden text-sm font-medium text-white bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 transition-all items-center gap-2 px-4 py-1.5 rounded-md shadow-lg shadow-indigo-900/30">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                    <span>Process All</span>
                </button>
                
                <input type="file" id="fileInput" accept="image/*" multiple class="hidden" />
            </div>
        </header>

        <div class="flex flex-1 overflow-hidden">
            <!-- Left Sidebar: Batch List -->
            <div class="w-24 md:w-64 bg-gray-900 border-r border-gray-800 flex flex-col shrink-0 z-20">
                <div class="p-3 border-b border-gray-800 flex justify-between items-center">
                    <span class="text-xs font-semibold text-gray-500 uppercase tracking-wider">Queue</span>
                    <span id="queueCount" class="text-[10px] bg-gray-800 text-gray-400 px-1.5 py-0.5 rounded">0</span>
                </div>
                <div id="batchList" class="flex-1 overflow-y-auto p-2 space-y-2">
                    <div id="emptyState" class="text-center py-10 text-gray-600 text-sm p-2">
                        No images. Add some to start.
                    </div>
                </div>
            </div>

            <!-- Center: Editor Workspace -->
            <main class="flex-1 bg-gray-950 p-4 md:p-8 overflow-y-auto flex flex-col items-center relative drop-zone" id="dropZone">
                <!-- Dot Pattern Background -->
                <div class="absolute inset-0 z-0 opacity-[0.03]" style="background-image: radial-gradient(#fff 1px, transparent 1px); background-size: 20px 20px;"></div>

                <div class="w-full max-w-5xl z-10 flex-1 flex flex-col justify-center min-h-[400px]">
                    <!-- Preview Container -->
                    <div id="previewContainer" class="w-full aspect-video bg-gray-900 rounded-lg flex items-center justify-center text-gray-500 border border-gray-700 overflow-hidden relative">
                        <div id="previewPlaceholder" class="text-center space-y-4">
                            <svg class="w-16 h-16 mx-auto text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                            </svg>
                            <p class="text-xl font-light text-gray-600">Drop images here or click Add Images</p>
                            <p class="text-sm text-gray-700">Unlimited batch processing - Process all images with one click</p>
                        </div>
                        <img id="previewImage" class="hidden w-full h-full object-contain" alt="Preview" />
                        <div id="processingOverlay" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center">
                            <div class="text-center w-64">
                                <div class="spinner w-12 h-12 mx-auto mb-4"></div>
                                <p id="processingText" class="text-indigo-400 font-medium animate-pulse mb-3">Processing...</p>
                                <div class="w-full bg-gray-800 rounded-full h-2 overflow-hidden">
                                    <div id="progressBar" class="progress-bar bg-gradient-to-r from-indigo-500 to-purple-500 h-full rounded-full" style="width: 0%"></div>
                                </div>
                                <p id="progressText" class="text-xs text-gray-500 mt-2">0 / 0</p>
                            </div>
                        </div>
                        <div id="dimensionBadge" class="hidden absolute top-4 right-4 bg-black/70 text-white text-xs px-2 py-1 rounded backdrop-blur-sm border border-white/10 font-mono">
                            7680 x 4320
                        </div>
                        <div id="enhanceBadge" class="hidden absolute top-4 right-20 bg-gradient-to-r from-amber-500 to-orange-600 text-white text-xs px-2 py-1 rounded shadow-lg font-bold tracking-wide flex items-center gap-1">
                            Enhanced
                        </div>
                    </div>
                </div>

                <!-- Floating Controls -->
                <div id="controlsPanel" class="hidden mt-6 z-10 w-full max-w-4xl bg-gray-900/95 backdrop-blur p-4 rounded-xl border border-gray-800 shadow-2xl">
                    <div class="flex flex-col xl:flex-row items-center justify-between gap-4">
                        <div class="flex flex-col md:flex-row items-center gap-4 w-full xl:w-auto">
                            <!-- Output Preset Selector -->
                            <div class="flex bg-gray-800 rounded-lg p-1 shrink-0">
                                <button id="preset8k" class="px-3 py-1.5 text-xs font-medium rounded-md transition-all bg-gray-700 text-white shadow-sm">
                                    8K Ultra
                                </button>
                                <button id="preset4k" class="px-3 py-1.5 text-xs font-medium rounded-md transition-all text-gray-400 hover:text-gray-200">
                                    4K
                                </button>
                                <button id="presetYT" class="px-3 py-1.5 text-xs font-medium rounded-md transition-all text-gray-400 hover:text-gray-200">
                                    YT Thumb
                                </button>
                                <button id="presetCustom" class="px-3 py-1.5 text-xs font-medium rounded-md transition-all text-gray-400 hover:text-gray-200">
                                    Custom
                                </button>
                            </div>

                            <div class="h-8 w-px bg-gray-700 hidden md:block"></div>

                            <!-- Fit Mode Toggles -->
                            <div class="flex items-center gap-2 overflow-x-auto max-w-full pb-1 md:pb-0">
                                <button id="fitBlur" class="fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-indigo-600 text-white shadow-lg shadow-indigo-900/50">
                                    Blur Fill
                                </button>
                                <button id="fitBlack" class="fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200">
                                    Black Bars
                                </button>
                                <button id="fitCrop" class="fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200">
                                    Crop
                                </button>
                            </div>

                            <div class="h-8 w-px bg-gray-700 hidden md:block"></div>

                            <!-- Enhancement Toggle -->
                            <button id="enhanceBtn" class="px-3 py-1.5 text-xs rounded-lg transition-all whitespace-nowrap flex items-center gap-2 bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200">
                                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                                Enhance
                            </button>
                        </div>

                        <!-- Download Button -->
                        <button id="downloadCurrentBtn" class="w-full xl:w-auto px-6 py-2 bg-white text-gray-900 rounded-lg font-semibold hover:bg-gray-200 transition-colors text-sm flex items-center justify-center gap-2 whitespace-nowrap">
                            Download Current
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                        </button>
                    </div>

                    <!-- Advanced Settings Row -->
                    <div class="mt-4 pt-4 border-t border-gray-800 flex flex-wrap items-center gap-6">
                        <!-- Output Format -->
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-500 font-medium">Format:</label>
                            <select id="outputFormat" class="bg-gray-800 text-white text-xs rounded-md px-2 py-1.5 border border-gray-700 focus:border-indigo-500 focus:outline-none">
                                <option value="jpeg">JPEG</option>
                                <option value="png">PNG</option>
                                <option value="webp">WebP</option>
                            </select>
                        </div>

                        <!-- Quality Slider -->
                        <div class="flex items-center gap-2 flex-1 min-w-[200px]">
                            <label class="text-xs text-gray-500 font-medium">Quality:</label>
                            <input type="range" id="qualitySlider" min="50" max="100" value="95" class="quality-slider flex-1 h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <span id="qualityValue" class="text-xs text-gray-400 w-8">95%</span>
                        </div>

                        <!-- Custom Dimensions (hidden by default) -->
                        <div id="customDimensions" class="hidden flex items-center gap-2">
                            <label class="text-xs text-gray-500 font-medium">Size:</label>
                            <input type="number" id="customWidth" placeholder="Width" class="bg-gray-800 text-white text-xs rounded-md px-2 py-1.5 border border-gray-700 w-20 focus:border-indigo-500 focus:outline-none">
                            <span class="text-gray-600">x</span>
                            <input type="number" id="customHeight" placeholder="Height" class="bg-gray-800 text-white text-xs rounded-md px-2 py-1.5 border border-gray-700 w-20 focus:border-indigo-500 focus:outline-none">
                        </div>

                        <!-- Apply to All Checkbox -->
                        <label class="flex items-center gap-2 cursor-pointer group">
                            <input type="checkbox" id="applyToAll" class="w-4 h-4 rounded border-gray-600 bg-gray-800 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-gray-900">
                            <span class="text-xs text-gray-400 group-hover:text-gray-300">Apply settings to all images</span>
                        </label>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // ============ STATE ============
        const PRESETS = {
            ULTRA_8K: { width: 7680, height: 4320, label: '8K Ultra' },
            UHD_4K: { width: 3840, height: 2160, label: '4K UHD' },
            YT_THUMBNAIL: { width: 1280, height: 720, label: 'YT Thumbnail' },
            CUSTOM: { width: 1920, height: 1080, label: 'Custom' }
        };
        
        const FIT_MODES = {
            CONTAIN_BLUR: 'CONTAIN_BLUR',
            CONTAIN_BLACK: 'CONTAIN_BLACK',
            COVER: 'COVER'
        };
        
        let state = {
            batchItems: [],
            selectedId: null,
            sourceImage: null,
            processedDataUrl: null,
            fitMode: FIT_MODES.CONTAIN_BLUR,
            outputPreset: 'ULTRA_8K',
            enhanceQuality: false,
            isProcessing: false,
            isZipping: false,
            outputFormat: 'jpeg',
            quality: 0.95,
            customWidth: 1920,
            customHeight: 1080,
            processingCache: new Map()
        };

        // ============ DOM ELEMENTS ============
        const elements = {
            fileInput: document.getElementById('fileInput'),
            addImagesBtn: document.getElementById('addImagesBtn'),
            clearAllBtn: document.getElementById('clearAllBtn'),
            processAllBtn: document.getElementById('processAllBtn'),
            batchList: document.getElementById('batchList'),
            emptyState: document.getElementById('emptyState'),
            queueCount: document.getElementById('queueCount'),
            imageCount: document.getElementById('imageCount'),
            previewContainer: document.getElementById('previewContainer'),
            previewPlaceholder: document.getElementById('previewPlaceholder'),
            previewImage: document.getElementById('previewImage'),
            processingOverlay: document.getElementById('processingOverlay'),
            processingText: document.getElementById('processingText'),
            progressBar: document.getElementById('progressBar'),
            progressText: document.getElementById('progressText'),
            dimensionBadge: document.getElementById('dimensionBadge'),
            enhanceBadge: document.getElementById('enhanceBadge'),
            controlsPanel: document.getElementById('controlsPanel'),
            dropZone: document.getElementById('dropZone'),
            preset8k: document.getElementById('preset8k'),
            preset4k: document.getElementById('preset4k'),
            presetYT: document.getElementById('presetYT'),
            presetCustom: document.getElementById('presetCustom'),
            fitBlur: document.getElementById('fitBlur'),
            fitBlack: document.getElementById('fitBlack'),
            fitCrop: document.getElementById('fitCrop'),
            enhanceBtn: document.getElementById('enhanceBtn'),
            downloadCurrentBtn: document.getElementById('downloadCurrentBtn'),
            outputFormat: document.getElementById('outputFormat'),
            qualitySlider: document.getElementById('qualitySlider'),
            qualityValue: document.getElementById('qualityValue'),
            customDimensions: document.getElementById('customDimensions'),
            customWidth: document.getElementById('customWidth'),
            customHeight: document.getElementById('customHeight'),
            applyToAll: document.getElementById('applyToAll')
        };

        // ============ NOTIFICATION SYSTEM ============
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast fixed top-4 right-4 z-50 px-4 py-2 rounded-lg text-sm font-medium text-white ${
                type === 'error' ? 'bg-red-600' : 
                type === 'success' ? 'bg-green-600' : 
                type === 'warning' ? 'bg-amber-600' : 'bg-indigo-600'
            }`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.3s';
                setTimeout(() => document.body.removeChild(toast), 300);
            }, 3000);
        }

        // ============ IMAGE PROCESSING ============
        function loadImage(source) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = source;
            });
        }

        function getOutputDimensions() {
            if (state.outputPreset === 'CUSTOM') {
                return {
                    width: state.customWidth || 1920,
                    height: state.customHeight || 1080
                };
            }
            return PRESETS[state.outputPreset];
        }

        function drawToCanvas(ctx, source, fitMode, targetW, targetH, enhance) {
            const srcW = source.width;
            const srcH = source.height;
            const targetRatio = targetW / targetH;
            const srcRatio = srcW / srcH;
            
            let drawW = targetW;
            let drawH = targetH;
            let offsetX = 0;
            let offsetY = 0;
            
            if (fitMode === FIT_MODES.COVER) {
                if (srcRatio > targetRatio) {
                    drawH = targetH;
                    drawW = srcW * (targetH / srcH);
                    offsetX = (targetW - drawW) / 2;
                } else {
                    drawW = targetW;
                    drawH = srcH * (targetW / srcW);
                    offsetY = (targetH - drawH) / 2;
                }
            } else if (fitMode === FIT_MODES.CONTAIN_BLACK || fitMode === FIT_MODES.CONTAIN_BLUR) {
                if (srcRatio > targetRatio) {
                    drawW = targetW;
                    drawH = srcH * (targetW / srcW);
                    offsetY = (targetH - drawH) / 2;
                } else {
                    drawH = targetH;
                    drawW = srcW * (targetH / srcH);
                    offsetX = (targetW - drawW) / 2;
                }
                
                if (fitMode === FIT_MODES.CONTAIN_BLUR) {
                    ctx.save();
                    const blurRadius = Math.max(40, Math.min(targetW, targetH) / 50);
                    ctx.filter = `blur(${blurRadius}px) brightness(0.7)`;
                    
                    const bgScale = Math.max(targetW / srcW, targetH / srcH);
                    const bgW = srcW * bgScale;
                    const bgH = srcH * bgScale;
                    const bgX = (targetW - bgW) / 2;
                    const bgY = (targetH - bgH) / 2;
                    ctx.drawImage(source, bgX, bgY, bgW, bgH);
                    ctx.restore();
                }
            }
            
            if (enhance) {
                ctx.filter = 'contrast(1.08) saturate(1.12) brightness(1.02)';
            }
            
            ctx.drawImage(source, offsetX, offsetY, drawW, drawH);
            ctx.filter = 'none';
            
            if (enhance) {
                const gradient = ctx.createRadialGradient(
                    targetW / 2, targetH / 2, targetW * 0.45,
                    targetW / 2, targetH / 2, targetW * 0.9
                );
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(0,0,0,0.25)');
                
                ctx.fillStyle = gradient;
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillRect(0, 0, targetW, targetH);
                ctx.globalCompositeOperation = 'source-over';
            }
            
            return { drawW, drawH, offsetX, offsetY };
        }

        function processImage(source, fitMode, enhance) {
            const { width: targetW, height: targetH } = getOutputDimensions();
            const cacheKey = `${fitMode}-${targetW}-${targetH}-${enhance}-${source.width}-${source.height}`;
            
            if (state.processingCache.has(cacheKey)) {
                return state.processingCache.get(cacheKey);
            }
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { alpha: false });
            
            canvas.width = targetW;
            canvas.height = targetH;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, targetW, targetH);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            drawToCanvas(ctx, source, fitMode, targetW, targetH, enhance);
            
            const mimeType = state.outputFormat === 'png' ? 'image/png' : 
                            state.outputFormat === 'webp' ? 'image/webp' : 'image/jpeg';
            const dataUrl = canvas.toDataURL(mimeType, state.quality);
            state.processingCache.set(cacheKey, dataUrl);
            
            if (state.processingCache.size > 50) {
                const firstKey = state.processingCache.keys().next().value;
                state.processingCache.delete(firstKey);
            }
            
            return dataUrl;
        }

        function processImageToBlob(source, fitMode, enhance) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { alpha: false });
                
                const { width: targetW, height: targetH } = getOutputDimensions();
                canvas.width = targetW;
                canvas.height = targetH;
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, targetW, targetH);
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                drawToCanvas(ctx, source, fitMode, targetW, targetH, enhance);
                
                const mimeType = state.outputFormat === 'png' ? 'image/png' : 
                                state.outputFormat === 'webp' ? 'image/webp' : 'image/jpeg';
                
                canvas.toBlob((blob) => {
                    if (blob) resolve(blob);
                    else reject(new Error("Canvas to Blob failed"));
                }, mimeType, state.quality);
            });
        }

        // ============ UI UPDATES ============
        function updateUI() {
            elements.queueCount.textContent = state.batchItems.length;
            elements.imageCount.textContent = `${state.batchItems.length} image${state.batchItems.length !== 1 ? 's' : ''} loaded`;
            
            if (state.batchItems.length > 0) {
                elements.processAllBtn.classList.remove('hidden');
                elements.processAllBtn.classList.add('flex');
                elements.clearAllBtn.classList.remove('hidden');
                elements.clearAllBtn.classList.add('flex');
            } else {
                elements.processAllBtn.classList.add('hidden');
                elements.processAllBtn.classList.remove('flex');
                elements.clearAllBtn.classList.add('hidden');
                elements.clearAllBtn.classList.remove('flex');
            }
            
            renderBatchList();
            updatePreview();
            
            if (state.selectedId) {
                elements.controlsPanel.classList.remove('hidden');
            } else {
                elements.controlsPanel.classList.add('hidden');
            }
            
            // Update preset buttons
            [elements.preset8k, elements.preset4k, elements.presetYT, elements.presetCustom].forEach(btn => {
                btn.className = 'px-3 py-1.5 text-xs font-medium rounded-md transition-all text-gray-400 hover:text-gray-200';
            });
            
            const activePresetBtn = {
                'ULTRA_8K': elements.preset8k,
                'UHD_4K': elements.preset4k,
                'YT_THUMBNAIL': elements.presetYT,
                'CUSTOM': elements.presetCustom
            }[state.outputPreset];
            
            if (activePresetBtn) {
                activePresetBtn.className = 'px-3 py-1.5 text-xs font-medium rounded-md transition-all bg-gray-700 text-white shadow-sm';
            }
            
            // Show/hide custom dimensions
            if (state.outputPreset === 'CUSTOM') {
                elements.customDimensions.classList.remove('hidden');
                elements.customDimensions.classList.add('flex');
            } else {
                elements.customDimensions.classList.add('hidden');
                elements.customDimensions.classList.remove('flex');
            }
            
            // Update fit mode buttons
            document.querySelectorAll('.fit-btn').forEach(btn => {
                btn.className = 'fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200';
            });
            
            if (state.fitMode === FIT_MODES.CONTAIN_BLUR) {
                elements.fitBlur.className = 'fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-indigo-600 text-white shadow-lg shadow-indigo-900/50';
            } else if (state.fitMode === FIT_MODES.CONTAIN_BLACK) {
                elements.fitBlack.className = 'fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-indigo-600 text-white shadow-lg shadow-indigo-900/50';
            } else if (state.fitMode === FIT_MODES.COVER) {
                elements.fitCrop.className = 'fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-indigo-600 text-white shadow-lg shadow-indigo-900/50';
            }
            
            // Update enhance button
            if (state.enhanceQuality) {
                elements.enhanceBtn.className = 'px-3 py-1.5 text-xs rounded-lg transition-all whitespace-nowrap flex items-center gap-2 bg-gradient-to-r from-amber-600 to-orange-600 text-white shadow-lg shadow-orange-900/50 ring-1 ring-orange-400/50';
            } else {
                elements.enhanceBtn.className = 'px-3 py-1.5 text-xs rounded-lg transition-all whitespace-nowrap flex items-center gap-2 bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200';
            }
            
            const { width, height } = getOutputDimensions();
            elements.dimensionBadge.textContent = `${width} x ${height}`;
        }

        function renderBatchList() {
            if (state.batchItems.length === 0) {
                elements.batchList.innerHTML = '<div class="text-center py-10 text-gray-600 text-sm p-2">No images. Add some to start.</div>';
                return;
            }
            
            elements.batchList.innerHTML = state.batchItems.map((item, idx) => `
                <div class="batch-item group relative flex items-center gap-3 p-2 rounded-lg cursor-pointer transition-all ${
                    state.selectedId === item.id 
                    ? 'bg-indigo-900/30 border border-indigo-500/30 ring-1 ring-indigo-500/20' 
                    : 'hover:bg-gray-800 border border-transparent'
                }" data-id="${item.id}">
                    <div class="w-16 h-9 bg-gray-950 rounded overflow-hidden shrink-0 relative">
                        <img src="${item.previewUrl}" alt="thumb" class="w-full h-full object-cover" loading="lazy" />
                        <div class="absolute top-0 right-0 bg-black/50 text-[8px] text-white px-1">${idx + 1}</div>
                        ${item.processed ? '<div class="absolute bottom-0 right-0 bg-green-500 text-[8px] text-white px-1">âœ“</div>' : ''}
                    </div>
                    <div class="flex-1 min-w-0 hidden md:block">
                        <p class="text-sm text-gray-200 truncate">${item.file.name}</p>
                        <p class="text-[10px] text-gray-500">${(item.file.size / 1024 / 1024).toFixed(2)} MB</p>
                    </div>
                    <button class="remove-btn absolute top-1 right-1 p-1 bg-red-500/80 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600" data-id="${item.id}" title="Remove">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            `).join('');
            
            document.querySelectorAll('.batch-item').forEach(el => {
                el.addEventListener('click', (e) => {
                    if (!e.target.closest('.remove-btn')) {
                        selectItem(el.dataset.id);
                    }
                });
            });
            
            document.querySelectorAll('.remove-btn').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeItem(el.dataset.id);
                });
            });
        }

        async function updatePreview() {
            if (!state.selectedId || !state.sourceImage) {
                elements.previewPlaceholder.classList.remove('hidden');
                elements.previewImage.classList.add('hidden');
                elements.dimensionBadge.classList.add('hidden');
                elements.enhanceBadge.classList.add('hidden');
                return;
            }
            
            elements.previewPlaceholder.classList.add('hidden');
            elements.previewImage.classList.remove('hidden');
            elements.dimensionBadge.classList.remove('hidden');
            
            if (state.enhanceQuality) {
                elements.enhanceBadge.classList.remove('hidden');
            } else {
                elements.enhanceBadge.classList.add('hidden');
            }
            
            try {
                const dataUrl = processImage(state.sourceImage, state.fitMode, state.enhanceQuality);
                state.processedDataUrl = dataUrl;
                elements.previewImage.src = dataUrl;
            } catch (e) {
                console.error('Processing failed:', e);
                showToast('Image processing failed', 'error');
            }
        }

        // ============ ACTIONS ============
        function validateFile(file) {
            if (!file.type.startsWith('image/')) {
                return false;
            }
            return true;
        }

        async function addFiles(files) {
            const filesArray = Array.from(files).filter(validateFile);
            
            if (filesArray.length === 0) {
                showToast('No valid image files selected', 'error');
                return;
            }
            
            const newItems = filesArray.map(file => ({
                id: crypto.randomUUID(),
                file,
                previewUrl: URL.createObjectURL(file),
                processedUrl: null,
                processed: false
            }));
            
            state.batchItems = [...state.batchItems, ...newItems];
            
            if (!state.selectedId && newItems.length > 0) {
                await selectItem(newItems[0].id);
            } else {
                updateUI();
            }
            
            showToast(`Added ${newItems.length} image${newItems.length > 1 ? 's' : ''}`, 'success');
        }

        async function selectItem(id) {
            state.selectedId = id;
            const item = state.batchItems.find(i => i.id === id);
            
            if (item) {
                try {
                    state.sourceImage = await loadImage(item.previewUrl);
                } catch (e) {
                    console.error('Failed to load image:', e);
                    showToast('Failed to load image', 'error');
                    state.sourceImage = null;
                }
            }
            
            state.processingCache.clear();
            updateUI();
            await updatePreview();
        }

        function removeItem(id) {
            const item = state.batchItems.find(i => i.id === id);
            if (item) {
                URL.revokeObjectURL(item.previewUrl);
            }
            
            state.batchItems = state.batchItems.filter(item => item.id !== id);
            
            if (id === state.selectedId) {
                if (state.batchItems.length > 0) {
                    selectItem(state.batchItems[0].id);
                } else {
                    state.selectedId = null;
                    state.sourceImage = null;
                    state.processedDataUrl = null;
                    state.processingCache.clear();
                }
            }
            
            updateUI();
            showToast('Image removed', 'info');
        }

        function clearAll() {
            state.batchItems.forEach(item => URL.revokeObjectURL(item.previewUrl));
            state.batchItems = [];
            state.selectedId = null;
            state.sourceImage = null;
            state.processedDataUrl = null;
            state.processingCache.clear();
            updateUI();
            showToast('All images cleared', 'info');
        }

        function downloadCurrent() {
            if (!state.processedDataUrl || !state.selectedId) return;
            
            const item = state.batchItems.find(i => i.id === state.selectedId);
            if (!item) return;
            
            const link = document.createElement('a');
            link.href = state.processedDataUrl;
            
            const { width, height } = getOutputDimensions();
            let suffix = `-${width}x${height}`;
            if (state.enhanceQuality) suffix += '-enhanced';
            
            const ext = state.outputFormat === 'png' ? '.png' : 
                       state.outputFormat === 'webp' ? '.webp' : '.jpg';
            
            const name = item.file.name.replace(/\.[^/.]+$/, "");
            link.download = `${name}${suffix}${ext}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('Download started', 'success');
        }

        async function processAll() {
            if (state.batchItems.length === 0 || state.isZipping) return;
            
            state.isZipping = true;
            const btn = elements.processAllBtn;
            const originalContent = btn.innerHTML;
            
            elements.processingOverlay.classList.remove('hidden');
            
            const zip = new JSZip();
            const { width, height } = getOutputDimensions();
            const folderName = `framecraft-${width}x${height}`;
            const folder = zip.folder(folderName);
            
            let successCount = 0;
            let failCount = 0;
            
            try {
                for (let i = 0; i < state.batchItems.length; i++) {
                    const item = state.batchItems[i];
                    const progress = Math.round(((i + 1) / state.batchItems.length) * 100);
                    
                    elements.processingText.textContent = `Processing image ${i + 1} of ${state.batchItems.length}`;
                    elements.progressBar.style.width = `${progress}%`;
                    elements.progressText.textContent = `${i + 1} / ${state.batchItems.length}`;
                    
                    btn.innerHTML = `
                        <div class="spinner w-4 h-4 border-2"></div>
                        <span>${progress}%</span>
                    `;
                    
                    await new Promise(resolve => setTimeout(resolve, 10));
                    
                    try {
                        const img = await loadImage(item.previewUrl);
                        const blob = await processImageToBlob(img, state.fitMode, state.enhanceQuality);
                        
                        let suffix = `-${width}x${height}`;
                        if (state.enhanceQuality) suffix += '-enhanced';
                        
                        const ext = state.outputFormat === 'png' ? '.png' : 
                                   state.outputFormat === 'webp' ? '.webp' : '.jpg';
                        
                        const fileName = item.file.name.replace(/\.[^/.]+$/, "") + suffix + ext;
                        folder.file(fileName, blob);
                        
                        item.processed = true;
                        successCount++;
                    } catch (err) {
                        console.error(`Failed: ${item.file.name}`, err);
                        failCount++;
                    }
                }
                
                if (failCount > 0) {
                    showToast(`${failCount} images failed to process`, 'warning');
                }
                
                elements.processingText.textContent = 'Generating ZIP file...';
                elements.progressBar.style.width = '100%';
                
                const content = await zip.generateAsync({ 
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 6 }
                });
                
                const url = URL.createObjectURL(content);
                const link = document.createElement('a');
                link.href = url;
                link.download = `framecraft-batch-${Date.now()}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showToast(`Successfully processed ${successCount} images`, 'success');
                
            } catch (err) {
                console.error("Batch processing failed", err);
                showToast("Failed to process batch", 'error');
            }
            
            state.isZipping = false;
            btn.innerHTML = originalContent;
            elements.processingOverlay.classList.add('hidden');
            elements.progressBar.style.width = '0%';
            updateUI();
        }

        // ============ EVENT LISTENERS ============
        elements.addImagesBtn.addEventListener('click', () => elements.fileInput.click());
        
        elements.fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                addFiles(e.target.files);
                e.target.value = '';
            }
        });
        
        elements.clearAllBtn.addEventListener('click', clearAll);
        elements.processAllBtn.addEventListener('click', processAll);
        elements.downloadCurrentBtn.addEventListener('click', downloadCurrent);
        
        elements.preset8k.addEventListener('click', () => {
            state.outputPreset = 'ULTRA_8K';
            state.processingCache.clear();
            updateUI();
            updatePreview();
        });
        
        elements.preset4k.addEventListener('click', () => {
            state.outputPreset = 'UHD_4K';
            state.processingCache.clear();
            updateUI();
            updatePreview();
        });
        
        elements.presetYT.addEventListener('click', () => {
            state.outputPreset = 'YT_THUMBNAIL';
            state.processingCache.clear();
            updateUI();
            updatePreview();
        });
        
        elements.presetCustom.addEventListener('click', () => {
            state.outputPreset = 'CUSTOM';
            state.processingCache.clear();
            updateUI();
            updatePreview();
        });
        
        elements.customWidth.addEventListener('change', (e) => {
            state.customWidth = parseInt(e.target.value) || 1920;
            state.processingCache.clear();
            updatePreview();
            updateUI();
        });
        
        elements.customHeight.addEventListener('change', (e) => {
            state.customHeight = parseInt(e.target.value) || 1080;
            state.processingCache.clear();
            updatePreview();
            updateUI();
        });
        
        elements.fitBlur.addEventListener('click', () => {
            state.fitMode = FIT_MODES.CONTAIN_BLUR;
            state.processingCache.clear();
            updateUI();
            updatePreview();
        });
        
        elements.fitBlack.addEventListener('click', () => {
            state.fitMode = FIT_MODES.CONTAIN_BLACK;
            state.processingCache.clear();
            updateUI();
            updatePreview();
        });
        
        elements.fitCrop.addEventListener('click', () => {
            state.fitMode = FIT_MODES.COVER;
            state.processingCache.clear();
            updateUI();
            updatePreview();
        });
        
        elements.enhanceBtn.addEventListener('click', () => {
            state.enhanceQuality = !state.enhanceQuality;
            state.processingCache.clear();
            updateUI();
            updatePreview();
        });
        
        elements.outputFormat.addEventListener('change', (e) => {
            state.outputFormat = e.target.value;
            state.processingCache.clear();
            updatePreview();
        });
        
        elements.qualitySlider.addEventListener('input', (e) => {
            state.quality = parseInt(e.target.value) / 100;
            elements.qualityValue.textContent = `${e.target.value}%`;
        });
        
        elements.qualitySlider.addEventListener('change', () => {
            state.processingCache.clear();
            updatePreview();
        });
        
        // Drag and Drop
        elements.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.dropZone.classList.add('dragover');
        });
        
        elements.dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            elements.dropZone.classList.remove('dragover');
        });
        
        elements.dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.dropZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
                if (imageFiles.length > 0) {
                    addFiles(imageFiles);
                }
            }
        });
        
        // Prevent default drag behavior on window
        window.addEventListener('dragover', (e) => e.preventDefault());
        window.addEventListener('drop', (e) => e.preventDefault());
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            state.batchItems.forEach(item => URL.revokeObjectURL(item.previewUrl));
            state.processingCache.clear();
        });
        
        // Initial UI update
        updateUI();
    </script>
</body>
</html>
